using ClassicalOrthogonalPolynomials, LazyBandedMatrices, LinearAlgebra, BlockArrays, RepresentationTheory, Test


# The symmetry group of the square is apparently S₄ × ℤ₂. It's irreps
# should be just the tensor product of the irreps of S₄ and ℤ₂. Since
# ℤ₂ has scalar irreps generated by 1 or -1 we should have generators of S₄
# alongside their negation. Let's check this out.

# First we need to figure out the generators, starting with rotation invariance.
# The isometry between the cube group and S₄ comes from permutation of diagonals.
# Label the 4 diagonals by (the span of)

a = [1,1,1]; b = [1,-1,1]; c = [1,1,-1]; d = [1,-1,-1]

# I.e. s₁ corresponds to permuting a and b, leaving c and d fixed. By inspection
# we find the 3 generators:

s₁ = [0 0 1;
      0 -1 0;
      1 0 0]

s₂ = [-1 0 0;
      0 0 -1;
      0 -1 0]

s₃ = [0 0 -1;
      0 -1 0;
      -1 0 0]

@test det(s₁) == det(s₂) == det(s₃) == 1
@test s₁ * [a b c d] == [b a -c -d] # swapping sign is fine
@test s₂ * [a b c d] == [-a -c -b -d]
@test s₃ * [a b c d] == [-a -b d c]

# We can also check the generator relationships directly

@test s₁^2 == s₂^2 == s₃^2 == I
@test s₁*s₃ == s₃*s₁
@test (s₁*s₂)^3 == (s₂*s₃)^3 == I

# OPs generate representations for these group actions


P = legendrep
Q = Array{Matrix{Float64}}(undef, 10)


ℙ₂ = (n,x,y) -> [P(n-k,x)P(k,y) for k=0:n]
ℙ = (n,x,y,z) -> vcat([P(n-k,x) .* ℙ₂(k,y,z) for k=0:n]...)
ℚ = (n, x, y, z) -> Q[n]'*ℙ(n, x, y, z)

x,y,z = 0.1,0.2,0.3
n = 1; 
@test ℙ(n,  z, -y,  x) ≈ s₁ * ℙ(n, x, y, z)
@test ℙ(n, -x, -z, -y) ≈ s₂ * ℙ(n, x, y, z)
@test ℙ(n, -z, -y, -x) ≈ s₃ * ℙ(n, x, y, z)
Q[1] = I(3)

# this is already an irrep
@test multiplicities(Representation([s₁,s₂,s₃]))[Partition([2,1,1])] == 1


n = 2
S₁ = sparse([6,5,3,4,2,1], 1:6, [1,-1,1,1,-1,1])
S₂ = sparse([1,3,2,6,5,4], 1:6, [1,1,1,1,1,1]) 
S₃ = sparse([6,5,3,4,2,1], 1:6, [1,1,1,1,1,1])
@test ℙ(n,  z, -y,  x) ≈ S₁ * ℙ(n,  x, y, z)
@test ℙ(n, -x, -z, -y) ≈ S₂ * ℙ(n, x, y, z)
@test ℙ(n, -z, -y, -x) ≈ S₃ * ℙ(n, x, y, z)

ρ,Q[n] = blockdiagonalize(Representation([S₁,S₂,S₃]))
@test Q[n]'Q[n] ≈ I

σ₁,σ₂,σ₃ = ρ.generators
@test ℚ(n,  z, -y,  x) ≈ σ₁*ℚ(n,  x, y, z)
@test ℚ(n, -x, -z, -y) ≈  σ₂*ℚ(n, x, y, z)
@test ℚ(n, -z, -y, -x) ≈  σ₃*ℚ(n, x, y, z)

n = 3
S₁ = sparse([10,9,6,8,5,3,7,4,2,1], 1:10, [1,-1,1,1,-1,1,-1,1,-1,1])
S₂ = sparse([1,3,2,6,5,4,10,9,8,7], 1:10, -ones(Int,10)) 
S₃ = sparse([10,9,6,8,5,3,7,4,2,1], 1:10, -ones(Int,10))
@test ℙ(n,  z, -y,  x) ≈ S₁ * ℙ(n,  x, y, z)
@test ℙ(n, -x, -z, -y) ≈ S₂ * ℙ(n, x, y, z)
@test ℙ(n, -z, -y, -x) ≈ S₃ * ℙ(n, x, y, z)

ρ,Q[n] = blockdiagonalize(Representation([S₁,S₂,S₃]))
@test Q[n]'Q[n] ≈ I

σ₁,σ₂,σ₃ = ρ.generators
@test ℚ(n,  z, -y,  x) ≈ σ₁*ℚ(n,  x, y, z)
@test ℚ(n, -x, -z, -y) ≈  σ₂*ℚ(n, x, y, z)
@test ℚ(n, -z, -y, -x) ≈  σ₃*ℚ(n, x, y, z)



# we now add in the ℤ₂ symmetry which should be (x,y,z) -> (-x,-y,-z)
# note this is a reflection + rotation but clearly we can get the basic
# reflections. E.g. the reflection (x,y,-z) can be produced as
#

@test -(s₁*s₂*s₃)^2 ≈ Diagonal([1,1,-1])

#
# The key point is it commutes with the rotations in the same way
# group products commute.
# We do a two stage process, first reduce to irreps of S₄. If we have
# only one copy of an irrep then we have that it is also an irrep of ℤ₂


n = 1; 
ℙ(n,  -x, -y, -z) ≈ -ℙ(n,  -x, -y, -z) # sign rep


n = 2
@test ℚ(n, -x, -y, -z) ≈ ℚ(n, x, y, z)

n = 3
@test ℚ(n, -x, -y, -z) ≈ -ℚ(n, x, y, z)