using ClassicalOrthogonalPolynomials, LazyBandedMatrices, LinearAlgebra, BlockArrays, NumericalRepresentationTheory, Test


@testset "Generators" begin
    # The symmetry group of the square is apparently Sâ‚„ Ã— â„¤â‚‚. It's irreps
    # should be just the tensor product of the irreps of Sâ‚„ and â„¤â‚‚. Since
    # â„¤â‚‚ has scalar irreps generated by 1 or -1 we should have generators of Sâ‚„
    # alongside their negation. Let's check this out.

    # First we need to figure out the generators, starting with rotation invariance.
    # The isometry between the cube group and Sâ‚„ comes from permutation of diagonals.
    # Label the 4 diagonals by (the span of)

    a = [1,1,1]; b = [1,-1,1]; c = [1,1,-1]; d = [1,-1,-1]

    # I.e. sâ‚ corresponds to permuting a and b, leaving c and d fixed. By inspection
    # we find the 3 generators:

    sâ‚ = [0 0 1;
        0 -1 0;
        1 0 0]

    sâ‚‚ = [-1 0 0;
        0 0 -1;
        0 -1 0]

    sâ‚ƒ = [0 0 -1;
        0 -1 0;
        -1 0 0]

    @test det(sâ‚) == det(sâ‚‚) == det(sâ‚ƒ) == 1
    @test sâ‚ * [a b c d] == [b a -c -d] # swapping sign is fine
    @test sâ‚‚ * [a b c d] == [-a -c -b -d]
    @test sâ‚ƒ * [a b c d] == [-a -b d c]

    # We can also check the generator relationships directly

    @test sâ‚^2 == sâ‚‚^2 == sâ‚ƒ^2 == I
    @test sâ‚*sâ‚ƒ == sâ‚ƒ*sâ‚
    @test (sâ‚*sâ‚‚)^3 == (sâ‚‚*sâ‚ƒ)^3 == I

    # OPs generate representations for these group actions


    P = legendrep
    Q = Array{Matrix{Float64}}(undef, 10)


    â„™â‚‚ = (n,x,y) -> [P(n-k,x)P(k,y) for k=0:n]
    â„™ = (n,x,y,z) -> vcat([P(n-k,x) .* â„™â‚‚(k,y,z) for k=0:n]...)
    â„š = (n, x, y, z) -> Q[n]'*â„™(n, x, y, z)

    x,y,z = 0.1,0.2,0.3
    n = 1; 
    @test â„™(n,  z, -y,  x) â‰ˆ sâ‚ * â„™(n, x, y, z)
    @test â„™(n, -x, -z, -y) â‰ˆ sâ‚‚ * â„™(n, x, y, z)
    @test â„™(n, -z, -y, -x) â‰ˆ sâ‚ƒ * â„™(n, x, y, z)
    Q[1] = I(3)

    # this is already an irrep
    @test multiplicities(Representation([sâ‚,sâ‚‚,sâ‚ƒ]))[Partition([2,1,1])] == 1


    n = 2
    Sâ‚ = sparse([6,5,3,4,2,1], 1:6, [1,-1,1,1,-1,1])
    Sâ‚‚ = sparse([1,3,2,6,5,4], 1:6, [1,1,1,1,1,1]) 
    Sâ‚ƒ = sparse([6,5,3,4,2,1], 1:6, [1,1,1,1,1,1])
    @test â„™(n,  z, -y,  x) â‰ˆ Sâ‚ * â„™(n,  x, y, z)
    @test â„™(n, -x, -z, -y) â‰ˆ Sâ‚‚ * â„™(n, x, y, z)
    @test â„™(n, -z, -y, -x) â‰ˆ Sâ‚ƒ * â„™(n, x, y, z)

    Ï,Q[n] = blockdiagonalize(Representation([Sâ‚,Sâ‚‚,Sâ‚ƒ]))
    @test Q[n]'Q[n] â‰ˆ I

    Ïƒâ‚,Ïƒâ‚‚,Ïƒâ‚ƒ = Ï.generators
    @test â„š(n,  z, -y,  x) â‰ˆ Ïƒâ‚*â„š(n,  x, y, z)
    @test â„š(n, -x, -z, -y) â‰ˆ  Ïƒâ‚‚*â„š(n, x, y, z)
    @test â„š(n, -z, -y, -x) â‰ˆ  Ïƒâ‚ƒ*â„š(n, x, y, z)

    n = 3
    Sâ‚ = sparse([10,9,6,8,5,3,7,4,2,1], 1:10, [1,-1,1,1,-1,1,-1,1,-1,1])
    Sâ‚‚ = sparse([1,3,2,6,5,4,10,9,8,7], 1:10, -ones(Int,10)) 
    Sâ‚ƒ = sparse([10,9,6,8,5,3,7,4,2,1], 1:10, -ones(Int,10))
    @test â„™(n,  z, -y,  x) â‰ˆ Sâ‚ * â„™(n,  x, y, z)
    @test â„™(n, -x, -z, -y) â‰ˆ Sâ‚‚ * â„™(n, x, y, z)
    @test â„™(n, -z, -y, -x) â‰ˆ Sâ‚ƒ * â„™(n, x, y, z)

    Ï,Q[n] = blockdiagonalize(Representation([Sâ‚,Sâ‚‚,Sâ‚ƒ]))
    @test Q[n]'Q[n] â‰ˆ I

    Ïƒâ‚,Ïƒâ‚‚,Ïƒâ‚ƒ = Ï.generators
    @test â„š(n,  z, -y,  x) â‰ˆ Ïƒâ‚*â„š(n,  x, y, z)
    @test â„š(n, -x, -z, -y) â‰ˆ  Ïƒâ‚‚*â„š(n, x, y, z)
    @test â„š(n, -z, -y, -x) â‰ˆ  Ïƒâ‚ƒ*â„š(n, x, y, z)



    # we now add in the â„¤â‚‚ symmetry which should be (x,y,z) -> (-x,-y,-z)
    # note this is a reflection + rotation but clearly we can get the basic
    # reflections. E.g. the reflection (x,y,-z) can be produced as
    #

    @test -(sâ‚*sâ‚‚*sâ‚ƒ)^2 â‰ˆ Diagonal([1,1,-1])

    #
    # The key point is it commutes with the rotations in the same way
    # group products commute.
    # We do a two stage process, first reduce to irreps of Sâ‚„. If we have
    # only one copy of an irrep then we have that it is also an irrep of â„¤â‚‚


    n = 1; 
    â„™(n,  -x, -y, -z) â‰ˆ -â„™(n,  -x, -y, -z) # sign rep


    n = 2
    @test â„š(n, -x, -y, -z) â‰ˆ â„š(n, x, y, z)

    n = 3
    @test â„š(n, -x, -y, -z) â‰ˆ -â„š(n, x, y, z)
end

@testset "cube generators" begin
let  P = Legendre(), N = 30, Pl = plan_transform(P, (N,N,N))
    ð±,ð²,ð³ = ClassicalOrthogonalPolynomials.grid(P, (N,N,N))
    function genrep(sym, n)
        ret = zeros(sum(1:n),sum(1:n))
        â„“ = 1
        for k = 1:n, j=1:k
            ð = (x,y,z) -> P[x,n-k+1] * P[y,k-j+1] * P[z,j]
            ðÌƒ = (x,y,z) -> ð(sym(x,y,z)...)
            ret[:,â„“] = DiagTrav(Pl* ðÌƒ.(ð±,ð²',reshape(ð³,1,1,:)))[Block(n)]
            â„“ += 1
        end
        ret
    end

    for n = 1:5
        @test genrep((x,y,z) -> (z,-y,x), n) â‰ˆ cubegen1(n)
        @test genrep((x,y,z) -> (-x, -z, -y), n) â‰ˆ cubegen2(n)
        @test genrep((x,y,z) -> (-z, -y, -x), n) â‰ˆ cubegen3(n)
    end
end


function blockdiagonalizepoly(n)
    Ï„1,Ï„2,Ï„3 = cubegen1(n), cubegen2(n), cubegen3(n)
    blockdiagonalize(Representation([Ï„1,Ï„2,Ï„3]))[2]
end


@testset "Expansion" begin
    P = Legendre()
    N = 30
    Pl = plan_transform(P, (N,N,N))
    ð±,ð²,ð³ = ClassicalOrthogonalPolynomials.grid(P, (N,N,N))
    f = (x,y,z) -> exp(-x^2 -2y^2 - 3(z-0.1)^2)
    F = f.(ð±,ð²', reshape(ð³,1,1,:))
    C = Pl*F
    
    x,y,z = 0.1,0.2,0.3
    @test sum(P[y,1:N]' .* C .* P[x,1:N] .* reshape(P[z,1:N],1,1,n)) â‰ˆ f(x,y,z)
    @test KronTrav(P[z,1:N], P[y,1:N], P[x,1:N])' * DiagTrav(C) â‰ˆ f(x,y,z)


    n = 3
    Q = blockdiagonalizepoly(n)
    s =  genrep((x,y,z) -> (-x,-y,-z), n)
    @test Q's*Q â‰ˆ I
    
    n = 4
    Q = blockdiagonalizepoly(n)
    s =  genrep((x,y,z) -> (-x,-y,-z), n)
    @test Q's*Q â‰ˆ -I
end

@testset "Poisson" begin
    N = 10
    Î” = (diff(P)'diff(P))[1:N,1:N]
    M = (P'P)[1:N,1:N]

    L = sparse(KronTrav(Î”, M, M)) + sparse(KronTrav(M, Î”, M)) + sparse(KronTrav(M, M, Î”))

    Qs = [blockdiagonalizepoly(n) for n=1:N]
    Q = blockdiag(sparse.(Qs)...)

    sparse(round.(Matrix(Q'*L*Q);digits=7))

    A = round.(Matrix(Q'*L*Q);digits=7)


    sparse9[:,end]
end


@testset "Schrodinger" begin
    x = axes(P,1)
    N = 10
    Î” = (diff(P)'diff(P))[1:N,1:N]
    M = (P'P)[1:N,1:N]
    XÂ² = ((P'P) * (P\(x.^2 .* P)))[1:N,1:N]


    V = sparse(KronTrav(XÂ², M, M)) + sparse(KronTrav(M, XÂ², M)) + sparse(KronTrav(M, M, XÂ²))

    A = L + V
    spy(round.(A;digits=7))
    spy(round.(Matrix(Q'*A*Q);digits=7))
end

