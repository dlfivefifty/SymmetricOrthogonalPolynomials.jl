using ClassicalOrthogonalPolynomials, LazyBandedMatrices, LinearAlgebra, BlockArrays, NumericalRepresentationTheory, Test


@testset "Generators" begin
      # The symmetry group of the square is apparently Sâ‚„ Ã— â„¤â‚‚. It's irreps
      # should be just the tensor product of the irreps of Sâ‚„ and â„¤â‚‚. Since
      # â„¤â‚‚ has scalar irreps generated by 1 or -1 we should have generators of Sâ‚„
      # alongside their negation. Let's check this out.

      # First we need to figure out the generators, starting with rotation invariance.
      # The isometry between the cube group and Sâ‚„ comes from permutation of diagonals.
      # Label the 4 diagonals by (the span of)

      a = [1,1,1]; b = [1,-1,1]; c = [1,1,-1]; d = [1,-1,-1]

      # I.e. sâ‚ corresponds to permuting a and b, leaving c and d fixed. By inspection
      # we find the 3 generators:

      sâ‚ = [0 0 1;
            0 -1 0;
            1 0 0]

      sâ‚‚ = [-1 0 0;
            0 0 -1;
            0 -1 0]

      sâ‚ƒ = [0 0 -1;
            0 -1 0;
            -1 0 0]

      @test det(sâ‚) == det(sâ‚‚) == det(sâ‚ƒ) == 1
      @test sâ‚ * [a b c d] == [b a -c -d] # swapping sign is fine
      @test sâ‚‚ * [a b c d] == [-a -c -b -d]
      @test sâ‚ƒ * [a b c d] == [-a -b d c]

      # We can also check the generator relationships directly

      @test sâ‚^2 == sâ‚‚^2 == sâ‚ƒ^2 == I
      @test sâ‚*sâ‚ƒ == sâ‚ƒ*sâ‚
      @test (sâ‚*sâ‚‚)^3 == (sâ‚‚*sâ‚ƒ)^3 == I

      # OPs generate representations for these group actions


      P = legendrep
      Q = Array{Matrix{Float64}}(undef, 10)


      â„™â‚‚ = (n,x,y) -> [P(n-k,x)P(k,y) for k=0:n]
      â„™ = (n,x,y,z) -> vcat([P(n-k,x) .* â„™â‚‚(k,y,z) for k=0:n]...)
      â„š = (n, x, y, z) -> Q[n]'*â„™(n, x, y, z)

      x,y,z = 0.1,0.2,0.3
      n = 1; 
      @test â„™(n,  z, -y,  x) â‰ˆ sâ‚ * â„™(n, x, y, z)
      @test â„™(n, -x, -z, -y) â‰ˆ sâ‚‚ * â„™(n, x, y, z)
      @test â„™(n, -z, -y, -x) â‰ˆ sâ‚ƒ * â„™(n, x, y, z)
      Q[1] = I(3)

      # this is already an irrep
      @test multiplicities(Representation([sâ‚,sâ‚‚,sâ‚ƒ]))[Partition([2,1,1])] == 1


      n = 2
      Sâ‚ = sparse([6,5,3,4,2,1], 1:6, [1,-1,1,1,-1,1])
      Sâ‚‚ = sparse([1,3,2,6,5,4], 1:6, [1,1,1,1,1,1]) 
      Sâ‚ƒ = sparse([6,5,3,4,2,1], 1:6, [1,1,1,1,1,1])
      @test â„™(n,  z, -y,  x) â‰ˆ Sâ‚ * â„™(n,  x, y, z)
      @test â„™(n, -x, -z, -y) â‰ˆ Sâ‚‚ * â„™(n, x, y, z)
      @test â„™(n, -z, -y, -x) â‰ˆ Sâ‚ƒ * â„™(n, x, y, z)

      Ï,Q[n] = blockdiagonalize(Representation([Sâ‚,Sâ‚‚,Sâ‚ƒ]))
      @test Q[n]'Q[n] â‰ˆ I

      Ïƒâ‚,Ïƒâ‚‚,Ïƒâ‚ƒ = Ï.generators
      @test â„š(n,  z, -y,  x) â‰ˆ Ïƒâ‚*â„š(n,  x, y, z)
      @test â„š(n, -x, -z, -y) â‰ˆ  Ïƒâ‚‚*â„š(n, x, y, z)
      @test â„š(n, -z, -y, -x) â‰ˆ  Ïƒâ‚ƒ*â„š(n, x, y, z)

      n = 3
      Sâ‚ = sparse([10,9,6,8,5,3,7,4,2,1], 1:10, [1,-1,1,1,-1,1,-1,1,-1,1])
      Sâ‚‚ = sparse([1,3,2,6,5,4,10,9,8,7], 1:10, -ones(Int,10)) 
      Sâ‚ƒ = sparse([10,9,6,8,5,3,7,4,2,1], 1:10, -ones(Int,10))
      @test â„™(n,  z, -y,  x) â‰ˆ Sâ‚ * â„™(n,  x, y, z)
      @test â„™(n, -x, -z, -y) â‰ˆ Sâ‚‚ * â„™(n, x, y, z)
      @test â„™(n, -z, -y, -x) â‰ˆ Sâ‚ƒ * â„™(n, x, y, z)

      Ï,Q[n] = blockdiagonalize(Representation([Sâ‚,Sâ‚‚,Sâ‚ƒ]))
      @test Q[n]'Q[n] â‰ˆ I

      Ïƒâ‚,Ïƒâ‚‚,Ïƒâ‚ƒ = Ï.generators
      @test â„š(n,  z, -y,  x) â‰ˆ Ïƒâ‚*â„š(n,  x, y, z)
      @test â„š(n, -x, -z, -y) â‰ˆ  Ïƒâ‚‚*â„š(n, x, y, z)
      @test â„š(n, -z, -y, -x) â‰ˆ  Ïƒâ‚ƒ*â„š(n, x, y, z)



      # we now add in the â„¤â‚‚ symmetry which should be (x,y,z) -> (-x,-y,-z)
      # note this is a reflection + rotation but clearly we can get the basic
      # reflections. E.g. the reflection (x,y,-z) can be produced as
      #

      @test -(sâ‚*sâ‚‚*sâ‚ƒ)^2 â‰ˆ Diagonal([1,1,-1])

      #
      # The key point is it commutes with the rotations in the same way
      # group products commute.
      # We do a two stage process, first reduce to irreps of Sâ‚„. If we have
      # only one copy of an irrep then we have that it is also an irrep of â„¤â‚‚


      n = 1; 
      â„™(n,  -x, -y, -z) â‰ˆ -â„™(n,  -x, -y, -z) # sign rep


      n = 2
      @test â„š(n, -x, -y, -z) â‰ˆ â„š(n, x, y, z)

      n = 3
      @test â„š(n, -x, -y, -z) â‰ˆ -â„š(n, x, y, z)
end

@testset "Expansion" begin
      P = Legendre()
      n = 30
      Pl = plan_transform(P, (n,n,n))
      ğ±,ğ²,ğ³ = ClassicalOrthogonalPolynomials.grid(P, (n,n,n))
      f = (x,y,z) -> exp(-x^2 -2y^2 - 3(z-0.1)^2)
      F = f.(ğ±,ğ²', reshape(ğ³,1,1,n))
      C = Pl*F
      
      x,y,z = 0.1,0.2,0.3
      @test sum(P[y,1:n]' .* C .* P[x,1:n] .* reshape(P[z,1:n],1,1,n)) â‰ˆ f(x,y,z)

      KronTrav(P[x,1:n], P[y,1:n], P[z,1:n])
      DiagTrav(C)
end

@testset "Poisson" begin
      
end